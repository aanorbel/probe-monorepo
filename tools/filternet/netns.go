package main

import (
	"fmt"
	"log"

	"github.com/google/shlex"
)

// NetnsScript is a complete description of what filternet should
// do with its input. Arguments are collected from the command line
// and are either processed by main or by Build().
type NetnsScript struct {
	// AddrPrefix is the prefix to use for addresses we are
	// going to use to communicate with the namespace. The
	// prefix must be an IPv4 /24 prefix, e.g, "10.0.0".
	AddrPrefix string `doc:"Optional /24 prefix to use for addresses (default: \"10.17.14\")"`

	// DNATRule contains iptables rules to apply before routing
	// the executed command's traffic (i.e., in PREROUTING).
	//
	// Say that your host's IP address is 192.168.1.5 and you have
	// a fake HTTP server on port 8080. Then, you can hijack
	// all HTTP traffic from the namespace with:
	//
	//     "-p tcp --dport 80 -j DNAT --to 192.168.1.5:8080"
	//
	// We will take care (1) of adding the rules to the proper
	// iptables table and (2) of removing such rules.
	DNATRule []string `doc:"Install a DNAT rule (e.g., use \"-p tcp --dport 80 -j DNAT --to 192.168.1.5:8080\" to hijack traffic to *:80/tcp)"`

	// DryRun configures a dry run where we don't actually execute commands.
	DryRun bool `doc:"Just prints what commands would be executed" short:"n"`

	// Downlink contains netem constraints for the downlink. If
	// empty, there will be no netem constraints.
	//
	// For example, you could set this field to
	//
	//     "delay 30ms rate 1mbit"
	//
	// to apply 30ms of delay and throttle at 1mbit/s the downlink.
	Downlink string `doc:"Netem constraints for the downlink (e.g., you can use \"delay 30ms rate 1mbit\" to reduce the download speed)"`

	// FirwallRule contains iptables rules to apply when routing
	// outgoing traffic generated by the executed command. Say that
	// you want to drop all the traffic to 8.8.8.8:443/udp. You
	// can do that with the following firewall rule:
	//
	//     "-d 8.8.8.8 -p udp --dport 443 -j DROP"
	//
	// We will take care (1) of adding the rules to the proper
	// iptables table and (2) of removing such rules.
	FirewallRule []string `doc:"Firewall outgoing traffic (e.g., use \"-d 8.8.8.8 -p udp --dport 443 -j DROP\" to block 8.8.8.8:443/udp)"`

	// Gateway is the output interface. This should
	// typically be your default gateway.
	Gateway string `doc:"Interface from which the traffic should exit (default: we'll discover your default gateway)"`

	// Help instructs the program to show the help message.
	Help bool `doc:"Shows this help message" short:"h"`

	// NamespaceName is the name of the namespace. We will use
	// this for the namespace and the related interfaces.
	NamespaceName string `doc:"Name of the network namespace (default: jafar)"`

	// Uplink is like Downlink but applies netem constraints to the uplink.
	Uplink string `doc:"Netem constraints for the uplink (e.g., you can use \"delay 30ms rate 1mbit\" to reduce the upload speed)"`

	// User indicates that we should run the main command
	// as the given user instead that as root.
	User string `doc:"user that should run the in-namespace command (default: run with the privileges of the user who's executing filternet)" short:"u"`

	// Workdir is the working directory.
	Workdir string `doc:"Directory in which to run the command" short:"w"`
}

// NewNetnsScript creates a new NetnsScript.
func NewNetnsScript() *NetnsScript {
	return &NetnsScript{
		Downlink:      "",
		Uplink:        "",
		FirewallRule:  nil,
		DNATRule:      nil,
		NamespaceName: "jafar",
		AddrPrefix:    "10.17.14",
	}
}

// Build builds a Script out of the NetnsScript.
func (ns *NetnsScript) Build(cc CommandConstructor, exec []string) *Script {
	out := &Script{}

	// 1. create the namespace proper
	//
	// See https://github.com/ooni/probe/issues/1803#issuecomment-942761976
	// for useful links explaining what we're doing here with netem.
	ns.addSetup(cc, out, "ip netns add %s", ns.NamespaceName)
	ns.addSetup(cc, out, "ip link add %s0 type veth peer netns %s name %s1",
		ns.NamespaceName, ns.NamespaceName, ns.NamespaceName)
	ns.addSetup(cc, out, "ip link set dev %s0 up", ns.NamespaceName)
	ns.addSetup(cc, out, "ip -n %s link set dev %s1 up", ns.NamespaceName, ns.NamespaceName)
	ns.addSetup(cc, out, "ip address add %s.1/24 dev %s0", ns.AddrPrefix, ns.NamespaceName)
	ns.addSetup(cc, out, "ip -n %s address add %s.11/24 dev %s1",
		ns.NamespaceName, ns.AddrPrefix, ns.NamespaceName)
	ns.addSetup(cc, out, "ip -n %s route add default via %s.1 dev %s1",
		ns.NamespaceName, ns.AddrPrefix, ns.NamespaceName)
	ns.addSetup(cc, out, "ip netns exec %s ip link set dev lo up", ns.NamespaceName)
	ns.addSetup(cc, out, "mkdir -p /etc/netns/%s/", ns.NamespaceName)

	// 2. ensure we have a resolv.conf for the namespace
	out.AddSetupCommand(cc.NewWriteLine(
		"nameserver 8.8.8.8",
		fmt.Sprintf("/etc/netns/%s/resolv.conf", ns.NamespaceName),
	))

	// 3. optionally configure netem
	if ns.Downlink != "" {
		ns.addSetup(cc, out, "tc qdisc add dev %s0 root handle 1: netem %s",
			ns.NamespaceName, ns.Downlink)
	}
	if ns.Uplink != "" {
		ns.addSetup(cc, out,
			"ip netns exec %s tc qdisc add dev %s1 root handle 1: netem %s",
			ns.NamespaceName, ns.NamespaceName, ns.Uplink,
		)
	}

	// 4. optionally set firewall rules
	for _, rule := range ns.FirewallRule {
		ns.addSetup(cc, out,
			"iptables -A FORWARD -i %s0 %s",
			ns.NamespaceName, rule,
		)
	}

	// 5. optionally set DNAT rules
	for _, rule := range ns.DNATRule {
		ns.addSetup(cc, out,
			"iptables -t nat -A PREROUTING -s %s.0/24 %s",
			ns.AddrPrefix, rule,
		)
	}

	// 6. setup masquerading for the namespace
	ns.addSetup(cc, out,
		"iptables -t nat -A POSTROUTING -s %s.0/24 -o %s -j MASQUERADE",
		ns.AddrPrefix, ns.Gateway,
	)

	// 7. run the main command
	if len(exec) > 0 {
		var args []string
		args = append(args, "ip", "netns", "exec", ns.NamespaceName)
		if ns.User != "" {
			args = append(args, "sudo", "-u", ns.User)
		}
		args = append(args, exec...)
		out.AddCommand(cc.NewCommand(args[0], args[1:]...))
	}

	// 8. remove the masquerading
	ns.addCleanup(cc, out,
		"iptables -t nat -D POSTROUTING -s %s.0/24 -o %s -j MASQUERADE",
		ns.AddrPrefix, ns.Gateway,
	)

	// 9. remove DNAT rules
	for _, rule := range ns.DNATRule {
		ns.addCleanup(cc, out,
			"iptables -t nat -D PREROUTING -s %s.0/24 %s",
			ns.AddrPrefix, rule,
		)
	}

	// 10. remove firewall rules
	for _, rule := range ns.FirewallRule {
		ns.addCleanup(cc, out,
			"iptables -D FORWARD -i %s0 %s",
			ns.NamespaceName, rule,
		)
	}

	// 11. disable netem
	// actually: no action required since we're removing the namespace

	// 12. remove the namespace's resolv.conf
	ns.addCleanup(cc, out, "rm -f /etc/netns/%s/resolv.conf", ns.NamespaceName)
	ns.addCleanup(cc, out, "rmdir /etc/netns/%s", ns.NamespaceName)

	// 13. remove the interfaces.
	ns.addCleanup(cc, out, "ip link del jafar0")

	// 14. destroy the namespace
	ns.addCleanup(cc, out, "ip netns del %s", ns.NamespaceName)

	return out
}

// addSetup adds a command to the setup script.
func (ns *NetnsScript) addSetup(
	cc CommandConstructor, out *Script, format string, v ...interface{}) {
	out.AddSetupCommand(ns.newCommand(cc, format, v...))
}

// addCleanup adds a command to the cleanup script.
func (ns *NetnsScript) addCleanup(
	cc CommandConstructor, out *Script, format string, v ...interface{}) {
	out.AddCleanupCommand(ns.newCommand(cc, format, v...))
}

// newCommand generates a new command.
func (ns *NetnsScript) newCommand(cc CommandConstructor,
	format string, v ...interface{}) Command {
	cmds := fmt.Sprintf(format, v...)
	av, err := shlex.Split(cmds)
	if err != nil {
		log.Fatalf("bug: cannot split internal command: %s", err.Error())
	}
	return cc.NewCommand(av[0], av[1:]...)
}
